//// [tests/cases/compiler/homomorphicMappedTypesPreserveCallConstructorSignatures.ts] ////

=== homomorphicMappedTypesPreserveCallConstructorSignatures.ts ===
type YesWithRenaming<T> = { [P in keyof T as `${P & string}bla`]: { value: YesWithRenaming<T[P]> } };
>YesWithRenaming : YesWithRenaming<T>
>value : YesWithRenaming<T[P]>

type YesWithoutRenaming<T> = { [P in keyof T]: { value: YesWithoutRenaming<T[P]> } };
>YesWithoutRenaming : YesWithoutRenaming<T>
>value : YesWithoutRenaming<T[P]>

type NoBecauseNotHomomorphic<T> = { [P in keyof T & PropertyKey]: { value: NoBecauseNotHomomorphic<T[P]> } };
>NoBecauseNotHomomorphic : NoBecauseNotHomomorphic<T>
>value : NoBecauseNotHomomorphic<T[P]>

interface Foo {
  (): string;
  (x: number): number;
>x : number

  prop: string;
>prop : string
}

interface Test {
  a: string;
>a : string

  b: number;
>b : number

  (): boolean;
  new(arg: unknown): { prop: unknown}
>arg : unknown
>prop : unknown

  readonly nested: {
>nested : { (): string; new (arg: unknown): {    prop: unknown;}; c?: boolean | undefined; readonly d: Foo; }

    (): string;
    c?: boolean;
>c : boolean | undefined

    new(arg: unknown): { prop: unknown}
>arg : unknown
>prop : unknown

    readonly d: Foo
>d : Foo
  }
}

type T1 = YesWithRenaming<Test>
>T1 : YesWithRenaming<Test>

type T2 = YesWithoutRenaming<Test>
>T2 : YesWithoutRenaming<Test>

type T3 = NoBecauseNotHomomorphic<Test>
>T3 : { a: { value: NoBecauseNotHomomorphic<string>; }; b: { value: NoBecauseNotHomomorphic<number>; }; nested: { value: NoBecauseNotHomomorphic<{ (): string; new (arg: unknown): { prop: unknown; }; c?: boolean | undefined; readonly d: Foo; }>; }; }

