//// [tests/cases/compiler/000.ts] ////

=== 000.ts ===
interface Test {
>Test : Symbol(Test, Decl(000.ts, 0, 0))

  a: number,
>a : Symbol(Test.a, Decl(000.ts, 0, 16))

  b: string,
>b : Symbol(Test.b, Decl(000.ts, 1, 12))

  c: boolean
>c : Symbol(Test.c, Decl(000.ts, 2, 12))
}

revert({ a: 1, b: '2', c: true, extra: 35 })
>revert : Symbol(revert, Decl(000.ts, 6, 44))
>a : Symbol(a, Decl(000.ts, 6, 8))
>b : Symbol(b, Decl(000.ts, 6, 14))
>c : Symbol(c, Decl(000.ts, 6, 22))
>extra : Symbol(extra, Decl(000.ts, 6, 31))


declare function revert<const T extends Test>(t: { [P in keyof T & keyof Test]: T[P] }): T
>revert : Symbol(revert, Decl(000.ts, 6, 44))
>T : Symbol(T, Decl(000.ts, 9, 24))
>Test : Symbol(Test, Decl(000.ts, 0, 0))
>t : Symbol(t, Decl(000.ts, 9, 46))
>P : Symbol(P, Decl(000.ts, 9, 52))
>T : Symbol(T, Decl(000.ts, 9, 24))
>Test : Symbol(Test, Decl(000.ts, 0, 0))
>T : Symbol(T, Decl(000.ts, 9, 24))
>P : Symbol(P, Decl(000.ts, 9, 52))
>T : Symbol(T, Decl(000.ts, 9, 24))

