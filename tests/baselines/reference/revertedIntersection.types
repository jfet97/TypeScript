//// [tests/cases/compiler/revertedIntersection.ts] ////

=== revertedIntersection.ts ===
type StateConfig<TAction extends string> = {
>StateConfig : StateConfig<TAction>

  entry?: TAction
>entry : TAction

  states?: Record<string, StateConfig<TAction>>;
>states : Record<string, StateConfig<TAction>>

};

type StateSchema = {
>StateSchema : { states?: Record<string, StateSchema>; }

  states?: Record<string, StateSchema>;
>states : Record<string, StateSchema>

};

declare function createMachine<
>createMachine : <TConfig extends StateConfig<TAction>, TAction extends string = TConfig["entry"] extends string ? TConfig["entry"] : string>(config: { [K in keyof TConfig & keyof StateConfig<TAction>]: TConfig[K]; }) => [TAction, TConfig]

  TConfig extends StateConfig<TAction>,
  TAction extends string = TConfig["entry"] extends string ? TConfig["entry"] : string,
>(config: { [K in keyof TConfig & keyof StateConfig<TAction>]: TConfig[K] }): [TAction, TConfig];
>config : { [K in keyof TConfig & keyof StateConfig<TAction>]: TConfig[K]; }

const inferredParams1 = createMachine({
>inferredParams1 : ["foo", StateConfig<"foo">]
>createMachine({  entry: "foo",  states: {    a: {      entry: "bar",    },  },  extra: 12,}) : ["foo", StateConfig<"foo">]
>createMachine : <TConfig extends StateConfig<TAction>, TAction extends string = TConfig["entry"] extends string ? TConfig["entry"] : string>(config: { [K in keyof TConfig & keyof StateConfig<TAction>]: TConfig[K]; }) => [TAction, TConfig]
>{  entry: "foo",  states: {    a: {      entry: "bar",    },  },  extra: 12,} : { entry: "foo"; states: { a: { entry: "bar"; }; }; extra: number; }

  entry: "foo",
>entry : "foo"
>"foo" : "foo"

  states: {
>states : { a: { entry: "bar"; }; }
>{    a: {      entry: "bar",    },  } : { a: { entry: "bar"; }; }

    a: {
>a : { entry: "bar"; }
>{      entry: "bar",    } : { entry: "bar"; }

      entry: "bar",
>entry : "bar"
>"bar" : "bar"

    },
  },
  extra: 12,
>extra : number
>12 : 12

});

const inferredParams2 = createMachine({
>inferredParams2 : ["foo", { entry: "foo"; states: { a: { entry: "foo"; }; }; extra: number; }]
>createMachine({  entry: "foo",  states: {    a: {      entry: "foo",    },  },  extra: 12,}) : ["foo", { entry: "foo"; states: { a: { entry: "foo"; }; }; extra: number; }]
>createMachine : <TConfig extends StateConfig<TAction>, TAction extends string = TConfig["entry"] extends string ? TConfig["entry"] : string>(config: { [K in keyof TConfig & keyof StateConfig<TAction>]: TConfig[K]; }) => [TAction, TConfig]
>{  entry: "foo",  states: {    a: {      entry: "foo",    },  },  extra: 12,} : { entry: "foo"; states: { a: { entry: "foo"; }; }; extra: number; }

  entry: "foo",
>entry : "foo"
>"foo" : "foo"

  states: {
>states : { a: { entry: "foo"; }; }
>{    a: {      entry: "foo",    },  } : { a: { entry: "foo"; }; }

    a: {
>a : { entry: "foo"; }
>{      entry: "foo",    } : { entry: "foo"; }

      entry: "foo",
>entry : "foo"
>"foo" : "foo"

    },
  },
  extra: 12,
>extra : number
>12 : 12

});


// -----------------------------------------------------------------------------------------

const checkType = <T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K]}) => value;
>checkType : <T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K]; }) => { [K in keyof U & keyof T]: U[K]; }
><T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K]}) => value : <T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K]; }) => { [K in keyof U & keyof T]: U[K]; }
><U extends T>(value: { [K in keyof U & keyof T]: U[K]}) => value : <U extends T>(value: { [K in keyof U & keyof T]: U[K]; }) => { [K in keyof U & keyof T]: U[K]; }
>value : { [K in keyof U & keyof T]: U[K]; }
>value : { [K in keyof U & keyof T]: U[K]; }

const checked = checkType<{x: number, y: string}>()({
>checked : { x: number; y: "y"; }
>checkType<{x: number, y: string}>()({  x: 1 as number,  y: "y",  z: "z", // undesirable property z is *not* allowed}) : { x: number; y: "y"; }
>checkType<{x: number, y: string}>() : <U extends { x: number; y: string; }>(value: { [K in keyof U & ("x" | "y")]: U[K]; }) => { [K in keyof U & ("x" | "y")]: U[K]; }
>checkType : <T>() => <U extends T>(value: { [K in keyof U & keyof T]: U[K]; }) => { [K in keyof U & keyof T]: U[K]; }
>x : number
>y : string
>{  x: 1 as number,  y: "y",  z: "z", // undesirable property z is *not* allowed} : { x: number; y: "y"; z: string; }

  x: 1 as number,
>x : number
>1 as number : number
>1 : 1

  y: "y",
>y : "y"
>"y" : "y"

  z: "z", // undesirable property z is *not* allowed
>z : string
>"z" : "z"

});

 checked;
>checked : { x: number; y: "y"; }

  // ^?
